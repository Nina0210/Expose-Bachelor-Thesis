\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}

\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{natbib}
\usepackage{titlesec}
\usepackage{multicol}

% Title Formatting
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}

\title{Efficient Approximate PageRank on Apache Spark: \\ A Memory-Aware Approach}
\author{Nina Michalek\\TU Berlin, DOS}
\date{March 29, 2025}

\begin{document}

\maketitle

\begin{multicols}{2}

\section{Introduction}
Today graphs are widely used to represent relationships between different entities for many applications such as social networks and website connections \cite{zhang_distributed_2021}. Therefor many specialized graph processing frameworks and algorithms have been introduced \cite{meng_survey_2024}. These systems can efficiently execute iterative algorithms such as PageRank \cite{gonzalez_graphx_nodate}. Apache Spark is an open-source distributed dataflow system that enables large-scale data processing \cite{shanahan_large_2015}. Built on top of Spark, GraphX is a graph processing framework that bridges the gap between system-level optimizations in specialized graph engines and the flexible dataflow operations available in general-purpose systems \cite{gonzalez_graphx_nodate}. However, recent research addresses the huge computational overhead in GraphX's PageRank algorithm and proposes approximate computing to reduce memory usage \cite{wu_efficient_2024}. 
 

\section{Problem Description}
PageRank is a broadly used graph algorithm introduced by Google. Many domains such as search engines, recommendation systems and social networks leverage PageRank. The algorithm measures the importance of websites \cite{wu_efficient_2024}. However, research shows that most implementations of the algorithm are inefficient when applied to large scale graphs due to a huge computational overhead \cite{wu_efficient_2024}\cite{jayaram_dynamic_2024}\cite{yang_efficient_2024}. GraphX's PageRank comes with a static and dynamic version. Static PageRank runs for a fixed number of iterations, while dynamic PageRank runs until the ranks convergence \cite{noauthor_graphx_nodate}. In both implementations, power iteration is used to update values \cite{xin_graphx_2013}, which requires many passes over the graph, resulting in costly matrix operations.  A fundamental challenge lies in the graph representation itself. Typically, graphs are represented in matrices, which require up to $O(n^2)$ of memory in the worst case \cite{wu_efficient_2024}. As graph sizes grow rapidly, the transition matrix becomes a significant memory bottleneck, making it increasingly impractical to store or process the entire matrix directly. This motivates the development of more scalable approaches that avoid full matrix construction and instead rely on efficient approximations \cite{meng_survey_2024}.



%In recent years many graph processing frameworks and algorithms have been introduced. 
%PageRank is a widely used graph algorithm introduced by Google. Today it is used by many domains such as search engines, recommendation systems and social networks. The algorithm measures the importance of websites. However, research shows that most implementations of the algorithm are not efficient on large graphs as there is a huge computational overhead. That is because some algorithms still don't use approximate PageRank values. PageRank leverages iterative convergence to compute values for the nodes. In the original implementation it uses power iteration, which requires many passes over the graph to converge. This is computationally expensive. Another problem with real world graphs is that typically they are sparse and irregular. Some nodes have thousands of links and others just a few. PageRank implementations have a static nature and therefor don't adapt to fast changing environments such as social media. However, one of the major problems is the graph representation. Usually the graph is represented in a matrix, which requires up to $O(n^2)$ of memory \cite{wu_efficient_2024}\cite{langville_googles_nodate}.


\section{State of the Art}
Today there are many approximate PageRank algorithms that address the computational overhead in the original implementation \cite{wu_efficient_2024}. They use different approaches to achieve a better performance. Some of them use iteration algorithms that work by updating the ranks step by step until the values stop changing much \cite{xie_parameterized_2023}\cite{anikin_efficient_2022}. Although there is a threshold it takes a lot of time on large graphs. Monte Carlo based algorithms use random walks instead of iterations, which means they simulate someone randomly clicking links on the graph to estimate the importance of nodes. For large graphs and high accuracy the algorithm requires a lot of these walks. Another approach only takes samples instead of the whole graph. It estimates the importance of a node by it's local area. In general they are faster because they only use local information but the runtime depends on the size of the area. However, the PageRank can only be estimated for nodes inside that area so computing the PageRank for the whole graph is not possible with the sampling method. Finally matrix approximation PageRank algorithms simplify the adjacency matrix by reducing the rank of the matrix to make computations easier. This results in faster computing time but usually the construction of low-rank matrices is high. Recent research addresses the problem and further optimizes the performance and accuracy by sampling substructures in the graph that are informative about node importance. It further simplifies the computation by constructing a low-rank approximation of the PageRank matrix using representative columns and rows \cite{wu_efficient_2024}. 

Apache Spark introduced GraphX in 2014 which features a static and dynamic implementation of the PageRank algorithm. While GraphX was a huge step forward in distributed graph processing, it has several limitations. Since PageRank has been part of GraphX's first release and GraphX is not actively maintained it has not had any major updates since then. Therefor the PageRank algorithm in Spark is often not suitable for practical modern use cases. Especially, memory limitations arising from the use of power iterations and the use of RDD-based message passing become significant performance bottlenecks \cite{xin_graphx_2013}.
 

\section{Approach}
The novel approach of the paper will be to implement an approximate PageRank algorithm on the open source system Apache Spark. As the existing GraphX library is not sufficient for real world use cases but poses a practical framework for many companies, the new implementation should address these issues and introduce an approach that focuses on low memory consumption. 
The result of recent research shows that there are several algorithms that perform better than the original one, but have not been implemented in an open source framework. The main goal of the thesis is to implement a state of the art method on the basis of Apache Spark that requires significantly less memory than GraphX's implementation. 

One idea is the $T^2$-Approx algorithm. It is a new method that addresses issues in existing algorithms and generalizes other matrix approximation-based PageRank algorithms. It uses a modified low-rank approximation of $T^2$, where $T$ is the transition matrix of the graph. It directly approximates $T^2$ by using two much smaller matrices $X$ and $Y$ instead of approximating $T$ and then computing $T^k$. It then estimates $T^k$ by building up powers of the small matrix. In general it uses low-rank approximation so that only a small number of rows and columns are used which drastically reduces memory. Since the PageRank algorithm doesn't always require exact values, this method is very helpful to reduce computational overhead.

Another algorithm that implements a more efficient version of PageRank is the CUR-Trans algorithm. It is based on a modified CUR decomposition, which is applied to to the transition matrix. The algorithm splits the large matrix $T$ into three small matrices $C, \tilde{U}$ and $R$, where $C$ and $R$ are sampled columns and rows and $\tilde{U}$ is a low-rank approximation of the intersection of $C$ and $R$. Then a new Graph is constructed with the matrices above that is much smaller than the original one. Finally PageRank is running on the smaller graph and the results are transformed back to the original graph.

After the implementation of a state of the art approach, the setup will be evaluated. As this paper tries to address the issue of inefficiency in GraphX's PageRank implementation, the primary evaluation metric will be memory usage. A tradeoff in accuracy is considered acceptable. The original GraphX's PageRank ialgorithm will serve as a baseline for comparison.



\section{References}
\bibliographystyle{plain}  % Choose a citation format
\bibliography{references}   % Link to your BibTeX file

\end{multicols}

\end{document}
