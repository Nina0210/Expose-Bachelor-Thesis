\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}       
\usepackage[polish,english]{babel} 
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}

\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{natbib}
\usepackage{titlesec}
%\usepackage{multicol}

% Title Formatting
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}

\title{Memory Efficient PageRank on Apache Spark}
\author{Nina Michalek\\TU Berlin, DOS}
\date{April 7, 2025}

\begin{document}

\maketitle

%\begin{multicols}{2}

\section{Introduction}
 Graphs are widely used to represent relationships between different entities for applications such as social networks and website connections \cite{zhang_distributed_2021}. 
To analyze these, numerous graph algorithms have been proposed. Among the most influential is PageRank, an iterative algorithm introduced by Google to determine website importance. PageRank has become a common component within specialized graph processing frameworks. These systems are designed to efficiently execute iterative algorithms, making graph analytics more practical. An example of such a system is GraphX \cite{xin_graphx_2013}, built upon Apache Spark \cite{xin_graphx_2013}. Spark itself is a popular open source distributed dataflow system that enables large-scale data processing \cite{shanahan_large_2015}. GraphX acts as a graph processing framework that aims to bridge the gap between system-level optimisations in specialised graph engines and the flexible dataflow operations available in general-purpose systems \cite{jin_software_2022}. However, recent research has addressed the huge memory overhead in GraphX's PageRank algorithm due to the data representation. It proposes approximate computation to reduce memory consumption \cite{wu_efficient_2024}. 
 

\section{Problem Description}
The rapid expansion of the World Wide Web during the late 1990's presented a significant challenge for the information retrieval cite. With the launch of Google in 1998 cite, PageRank was introduced as a core component of the search engine cite. PageRank is an algorithm that is ranking web pages by measuring their relative importance based on the graph of the web \cite{page_pagerank_1999}. The nodes of the graph are the web pages while the edges represent links. An outedge is a link on a website and an inedge is a backlink \cite{page_pagerank_1999}. A page is considered important if it has inedges from important pages. The value of a web page is calculated recursively based on the values of all pages linking to it. Linking pages pass a fraction of its own value, proportional to its number of outedges, to the target page. This is an iterative calculation with a damping factor that converges to a stable probability distribution \cite{page_pagerank_1999}. 
Today PageRank is used, not only in search engines, but in a wide range of applications such as social networks \cite{wu_efficient_2024}. The latter utilizes PageRank to identify influential users, rank content in feeds and recommend people \cite{weng_twitterrank_2010}. Despite its wide applicability, a fundamental challenge lies in the graph representation \cite{liu_fast_2015}. Typically, graphs are represented in matrices, which in the worst case require up to $O(n^2)$ of memory, where $n$ is the number of web pages \cite{wu_efficient_2024}. The transition matrix, containing the probabilities of moving from one web page to another in a single step, presents a significant memory challenge as graph sizes grow. 



\section{State of the Art}
Numerous approaches, such as Apache Spark's GraphX framework \cite{xin_graphx_2013}, have been introduced to address the computational overhead of the standard power iteration algorithm \cite{page_pagerank_1999}.
GraphX uses a vertex-centric model, strongly inspired by Pregel \cite{malewicz_pregel_2010}, which partitions the graph across a cluster to allow efficient distributed communication and state updates. It improves performance over general-purpose dataflow systems \cite{jin_software_2022}. However, GraphX's PageRank still has limitations on massive graphs, including significant memory requirements for storing the graph structure \cite{wu_efficient_2024}\cite{xin_graphx_2014}. Therefore, approximate PageRank algorithms have been proposed for practical large-scale analysis that trade off accuracy for efficiency \cite{wu_efficient_2024}. The following methods have been introduced:
\textbf{Iteration methods} \cite{xie_parameterised_2023}\cite{anikin_efficient_2022} accelerate the standard power iteration but still operate on the whole graph structure \cite{wu_efficient_2024}. 
\textbf{Sampling-based methods} estimate PageRank values by using smaller, sampled subgraphs \cite{bar-yossef_local_2008}\cite{chen_local_2004}. Although they reduce the size of the input data, these methods cannot estimate the PageRank values for the vertices outside the sampled set \cite{wu_efficient_2024}.
\textbf{Matrix approximation methods} use a low-rank approximated transition matrix to estimate PageRank values \cite{liu_fast_2015}\cite{benczur_feasibility_2005}. 
\textbf{Monte Carlo methods} estimate PageRank by simulating random walks on the graph. Instead of iteratively updating a full rank vector, these models simulate many random walks on the graph \cite{avrachenkov_monte_2007}. The value of a node is estimated by the number of walks that end at the vertex. In order to achieve high accuracy, these methods have to go through a large number of iterations \cite{wu_efficient_2024}. However, the memory required during the simulation can be controlled by the number of concurrent random walkers rather than by the total number of vertices \cite{avrachenkov_monte_2007}. Given the potential memory advantages by controlling the random walker count, Monte Carlo methods offer a promising direction for large-scale PageRank approximation.
 

\section{Approach}
The goal of the thesis will be to implement a memory-efficient alternative to GraphX's iterative PageRank computation by using a RDD-based Monte Carlo method in Apache Spark. The given memory advantage in Monte Carlo methods stated above, offer an approach that achieve lower peak memory usage compared to GraphX's Power Iteration on the whole graph. Especially when processing large graphs. A trade-off in accuracy and performance due to low memory capacity is accepted. 
The implementation uses RDDs to represent the graph structure  and the dynamic states of concurrent random walkers. The core simulation phase iteratively computes the next position for each walker over a predetermined number of steps (k). Each step involves joining the current walker state RDD with the persisted graph structure RDD to determine available transitions. Subsequently, standard Spark transformations apply the PageRank random surfer model logic: each walker either follows a randomly selected outgoing link with probability d (damping factor) or teleports to a random node with probability 1-d, appropriately handling dangling nodes. Crucially, intermediate walker state RDDs from previous steps will be unpersisted to manage memory consumption throughout the simulation. Finally the PageRank scores are estimated based on the final walker states. The number of walkers as well as the setp size directly influence the memory required and the performance. The thesis will evaluate the trade-offs by varying the number of walkers and the step size. The memory usage, execution times and accuracy will be benchmarked against GraphX's PageRank implementaion.


%As the existing GraphX library is not sufficient for large-scale graphs but poses a practical framework for many users, the new implementation should address the computational overhead and introduce an approach that focuses on low memory consumption. 
%The result of recent research shows that there are several algorithms that perform better than the original PageRank algorithm \cite{wu_efficient_2024}, but have not been implemented in a general use framework. The main goal of the thesis is to implement a state of the art method on the basis of Apache Spark that requires less memory than GraphX's PageRank implementation. 

%One idea is the $T^2$-Approx algorithm \cite{wu_efficient_2024}. It addresses issues in existing algorithms and generalizes other matrix approximation-based PageRank algorithms. The algorithm uses a modified low-rank approximation of $T^2$, where $T$ is the transition matrix of the graph. It directly approximates $T^2$ by using two smaller matrices $X$ and $Y$ instead of approximating $T$ and then computing $T^k$. It then estimates $T^k$ by iteratively computing powers of the small matrix. The approach relies on low-rank approximation, leveraging only a subset of rows and columns, which significantly reduces memory consumption. Since the PageRank algorithm tolerates approximate values, this method is an effective way to reduce computational overhead.

%Another algorithm that implements a more efficient version of PageRank is the CUR-Trans algorithm \cite{wu_efficient_2024}. It is based on a modified CUR decomposition, which is applied to the transition matrix. The algorithm splits the large matrix $T$ into three small matrices $C, \tilde{U}$ and $R$, where $C$ and $R$ are sampled columns and rows and $\tilde{U}$ is a low-rank approximation of the intersection of $C$ and $R$. A new, significantly smaller Graph is then constructed based on the matrices. The PageRank algorithm is running on the reduced graph and the results are mapped back to the initial graph.

%After the implementation of a state of the art approach, the setup will be evaluated. As this thesis aims to address the inefficiencies in GraphX's PageRank implementation, the primary evaluation metric will be the memory usage. A tradeoff in accuracy is considered acceptable. The original GraphX's PageRank algorithm will serve as a baseline for comparison. 




\bibliographystyle{plain}  % Choose a citation format
\bibliography{references}   % Link to your BibTeX file

%\end{multicols}

\end{document}
